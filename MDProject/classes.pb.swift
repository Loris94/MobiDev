// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: classes.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct ProfileProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var serverAddress: String = String()

  var serverPort: UInt32 = 0

  var sessionName: String = String()

  var sensor: [SensorProto] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SensorProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var name: String = String()

  var status: Bool = false

  var parameter: [SensorParameterProto] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SensorParameterProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var key: String {
    get {return _storage._key}
    set {_uniqueStorage()._key = newValue}
  }

  var value: SensorParameterValueProto {
    get {return _storage._value ?? SensorParameterValueProto()}
    set {_uniqueStorage()._value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  var hasValue: Bool {return _storage._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  mutating func clearValue() {_uniqueStorage()._value = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct SensorParameterValueProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var doubleValue: Double = 0

  var strValue: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct AccelerationDataProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var x: Double = 0

  var y: Double = 0

  var z: Double = 0

  var timestamp: Double = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct GyroDataProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var x: Double = 0

  var y: Double = 0

  var z: Double = 0

  var timestamp: Double = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct DataProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var accelerationData: [AccelerationDataProto] = []

  var gyroData: [GyroDataProto] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct GyroDataProto2 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var x: Double = 0

  var y: Double = 0

  var z: Double = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct AccelerationDataProto2 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var x: Double = 0

  var y: Double = 0

  var z: Double = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct ImageProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var base64: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct MagnetometerDataProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var x: Double = 0

  var y: Double = 0

  var z: Double = 0

  var accuracy: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CompassDataProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var x: Double = 0

  var y: Double = 0

  var z: Double = 0

  var trueHeading: Double = 0

  var magneticHeading: Double = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SensorUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var timestamp: Double {
    get {return _storage._timestamp}
    set {_uniqueStorage()._timestamp = newValue}
  }

  var session: String {
    get {return _storage._session}
    set {_uniqueStorage()._session = newValue}
  }

  var type: String {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  var accelerationData: AccelerationDataProto2 {
    get {return _storage._accelerationData ?? AccelerationDataProto2()}
    set {_uniqueStorage()._accelerationData = newValue}
  }
  /// Returns true if `accelerationData` has been explicitly set.
  var hasAccelerationData: Bool {return _storage._accelerationData != nil}
  /// Clears the value of `accelerationData`. Subsequent reads from it will return its default value.
  mutating func clearAccelerationData() {_uniqueStorage()._accelerationData = nil}

  var gyroData: GyroDataProto2 {
    get {return _storage._gyroData ?? GyroDataProto2()}
    set {_uniqueStorage()._gyroData = newValue}
  }
  /// Returns true if `gyroData` has been explicitly set.
  var hasGyroData: Bool {return _storage._gyroData != nil}
  /// Clears the value of `gyroData`. Subsequent reads from it will return its default value.
  mutating func clearGyroData() {_uniqueStorage()._gyroData = nil}

  var imageData: ImageProto {
    get {return _storage._imageData ?? ImageProto()}
    set {_uniqueStorage()._imageData = newValue}
  }
  /// Returns true if `imageData` has been explicitly set.
  var hasImageData: Bool {return _storage._imageData != nil}
  /// Clears the value of `imageData`. Subsequent reads from it will return its default value.
  mutating func clearImageData() {_uniqueStorage()._imageData = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension ProfileProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ProfileProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "serverAddress"),
    2: .same(proto: "serverPort"),
    3: .same(proto: "sessionName"),
    4: .same(proto: "sensor"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.serverAddress)
      case 2: try decoder.decodeSingularUInt32Field(value: &self.serverPort)
      case 3: try decoder.decodeSingularStringField(value: &self.sessionName)
      case 4: try decoder.decodeRepeatedMessageField(value: &self.sensor)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.serverAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.serverAddress, fieldNumber: 1)
    }
    if self.serverPort != 0 {
      try visitor.visitSingularUInt32Field(value: self.serverPort, fieldNumber: 2)
    }
    if !self.sessionName.isEmpty {
      try visitor.visitSingularStringField(value: self.sessionName, fieldNumber: 3)
    }
    if !self.sensor.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sensor, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ProfileProto, rhs: ProfileProto) -> Bool {
    if lhs.serverAddress != rhs.serverAddress {return false}
    if lhs.serverPort != rhs.serverPort {return false}
    if lhs.sessionName != rhs.sessionName {return false}
    if lhs.sensor != rhs.sensor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SensorProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "SensorProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "status"),
    3: .same(proto: "parameter"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.name)
      case 2: try decoder.decodeSingularBoolField(value: &self.status)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.parameter)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.status != false {
      try visitor.visitSingularBoolField(value: self.status, fieldNumber: 2)
    }
    if !self.parameter.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.parameter, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SensorProto, rhs: SensorProto) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.status != rhs.status {return false}
    if lhs.parameter != rhs.parameter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SensorParameterProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "SensorParameterProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "value"),
  ]

  fileprivate class _StorageClass {
    var _key: String = String()
    var _value: SensorParameterValueProto? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _key = source._key
      _value = source._value
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._key)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._value)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._key.isEmpty {
        try visitor.visitSingularStringField(value: _storage._key, fieldNumber: 1)
      }
      if let v = _storage._value {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SensorParameterProto, rhs: SensorParameterProto) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._key != rhs_storage._key {return false}
        if _storage._value != rhs_storage._value {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SensorParameterValueProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "SensorParameterValueProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "doubleValue"),
    2: .same(proto: "strValue"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularDoubleField(value: &self.doubleValue)
      case 2: try decoder.decodeSingularStringField(value: &self.strValue)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.doubleValue != 0 {
      try visitor.visitSingularDoubleField(value: self.doubleValue, fieldNumber: 1)
    }
    if !self.strValue.isEmpty {
      try visitor.visitSingularStringField(value: self.strValue, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SensorParameterValueProto, rhs: SensorParameterValueProto) -> Bool {
    if lhs.doubleValue != rhs.doubleValue {return false}
    if lhs.strValue != rhs.strValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AccelerationDataProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "AccelerationDataProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "x"),
    2: .same(proto: "y"),
    3: .same(proto: "z"),
    4: .same(proto: "timestamp"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularDoubleField(value: &self.x)
      case 2: try decoder.decodeSingularDoubleField(value: &self.y)
      case 3: try decoder.decodeSingularDoubleField(value: &self.z)
      case 4: try decoder.decodeSingularDoubleField(value: &self.timestamp)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.x != 0 {
      try visitor.visitSingularDoubleField(value: self.x, fieldNumber: 1)
    }
    if self.y != 0 {
      try visitor.visitSingularDoubleField(value: self.y, fieldNumber: 2)
    }
    if self.z != 0 {
      try visitor.visitSingularDoubleField(value: self.z, fieldNumber: 3)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularDoubleField(value: self.timestamp, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AccelerationDataProto, rhs: AccelerationDataProto) -> Bool {
    if lhs.x != rhs.x {return false}
    if lhs.y != rhs.y {return false}
    if lhs.z != rhs.z {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GyroDataProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "GyroDataProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "x"),
    2: .same(proto: "y"),
    3: .same(proto: "z"),
    4: .same(proto: "timestamp"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularDoubleField(value: &self.x)
      case 2: try decoder.decodeSingularDoubleField(value: &self.y)
      case 3: try decoder.decodeSingularDoubleField(value: &self.z)
      case 4: try decoder.decodeSingularDoubleField(value: &self.timestamp)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.x != 0 {
      try visitor.visitSingularDoubleField(value: self.x, fieldNumber: 1)
    }
    if self.y != 0 {
      try visitor.visitSingularDoubleField(value: self.y, fieldNumber: 2)
    }
    if self.z != 0 {
      try visitor.visitSingularDoubleField(value: self.z, fieldNumber: 3)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularDoubleField(value: self.timestamp, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GyroDataProto, rhs: GyroDataProto) -> Bool {
    if lhs.x != rhs.x {return false}
    if lhs.y != rhs.y {return false}
    if lhs.z != rhs.z {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DataProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "DataProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "accelerationData"),
    2: .same(proto: "gyroData"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.accelerationData)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.gyroData)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.accelerationData.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.accelerationData, fieldNumber: 1)
    }
    if !self.gyroData.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.gyroData, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DataProto, rhs: DataProto) -> Bool {
    if lhs.accelerationData != rhs.accelerationData {return false}
    if lhs.gyroData != rhs.gyroData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GyroDataProto2: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "GyroDataProto2"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "x"),
    2: .same(proto: "y"),
    3: .same(proto: "z"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularDoubleField(value: &self.x)
      case 2: try decoder.decodeSingularDoubleField(value: &self.y)
      case 3: try decoder.decodeSingularDoubleField(value: &self.z)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.x != 0 {
      try visitor.visitSingularDoubleField(value: self.x, fieldNumber: 1)
    }
    if self.y != 0 {
      try visitor.visitSingularDoubleField(value: self.y, fieldNumber: 2)
    }
    if self.z != 0 {
      try visitor.visitSingularDoubleField(value: self.z, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GyroDataProto2, rhs: GyroDataProto2) -> Bool {
    if lhs.x != rhs.x {return false}
    if lhs.y != rhs.y {return false}
    if lhs.z != rhs.z {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AccelerationDataProto2: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "AccelerationDataProto2"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "x"),
    2: .same(proto: "y"),
    3: .same(proto: "z"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularDoubleField(value: &self.x)
      case 2: try decoder.decodeSingularDoubleField(value: &self.y)
      case 3: try decoder.decodeSingularDoubleField(value: &self.z)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.x != 0 {
      try visitor.visitSingularDoubleField(value: self.x, fieldNumber: 1)
    }
    if self.y != 0 {
      try visitor.visitSingularDoubleField(value: self.y, fieldNumber: 2)
    }
    if self.z != 0 {
      try visitor.visitSingularDoubleField(value: self.z, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AccelerationDataProto2, rhs: AccelerationDataProto2) -> Bool {
    if lhs.x != rhs.x {return false}
    if lhs.y != rhs.y {return false}
    if lhs.z != rhs.z {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ImageProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ImageProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "base64"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.base64)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.base64.isEmpty {
      try visitor.visitSingularStringField(value: self.base64, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ImageProto, rhs: ImageProto) -> Bool {
    if lhs.base64 != rhs.base64 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MagnetometerDataProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "MagnetometerDataProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "x"),
    2: .same(proto: "y"),
    3: .same(proto: "z"),
    4: .same(proto: "accuracy"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularDoubleField(value: &self.x)
      case 2: try decoder.decodeSingularDoubleField(value: &self.y)
      case 3: try decoder.decodeSingularDoubleField(value: &self.z)
      case 4: try decoder.decodeSingularInt32Field(value: &self.accuracy)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.x != 0 {
      try visitor.visitSingularDoubleField(value: self.x, fieldNumber: 1)
    }
    if self.y != 0 {
      try visitor.visitSingularDoubleField(value: self.y, fieldNumber: 2)
    }
    if self.z != 0 {
      try visitor.visitSingularDoubleField(value: self.z, fieldNumber: 3)
    }
    if self.accuracy != 0 {
      try visitor.visitSingularInt32Field(value: self.accuracy, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: MagnetometerDataProto, rhs: MagnetometerDataProto) -> Bool {
    if lhs.x != rhs.x {return false}
    if lhs.y != rhs.y {return false}
    if lhs.z != rhs.z {return false}
    if lhs.accuracy != rhs.accuracy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CompassDataProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CompassDataProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "x"),
    2: .same(proto: "y"),
    3: .same(proto: "z"),
    4: .same(proto: "trueHeading"),
    5: .same(proto: "magneticHeading"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularDoubleField(value: &self.x)
      case 2: try decoder.decodeSingularDoubleField(value: &self.y)
      case 3: try decoder.decodeSingularDoubleField(value: &self.z)
      case 4: try decoder.decodeSingularDoubleField(value: &self.trueHeading)
      case 5: try decoder.decodeSingularDoubleField(value: &self.magneticHeading)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.x != 0 {
      try visitor.visitSingularDoubleField(value: self.x, fieldNumber: 1)
    }
    if self.y != 0 {
      try visitor.visitSingularDoubleField(value: self.y, fieldNumber: 2)
    }
    if self.z != 0 {
      try visitor.visitSingularDoubleField(value: self.z, fieldNumber: 3)
    }
    if self.trueHeading != 0 {
      try visitor.visitSingularDoubleField(value: self.trueHeading, fieldNumber: 4)
    }
    if self.magneticHeading != 0 {
      try visitor.visitSingularDoubleField(value: self.magneticHeading, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CompassDataProto, rhs: CompassDataProto) -> Bool {
    if lhs.x != rhs.x {return false}
    if lhs.y != rhs.y {return false}
    if lhs.z != rhs.z {return false}
    if lhs.trueHeading != rhs.trueHeading {return false}
    if lhs.magneticHeading != rhs.magneticHeading {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SensorUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "SensorUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "timestamp"),
    2: .same(proto: "session"),
    3: .same(proto: "type"),
    4: .same(proto: "accelerationData"),
    5: .same(proto: "gyroData"),
    6: .same(proto: "ImageData"),
  ]

  fileprivate class _StorageClass {
    var _timestamp: Double = 0
    var _session: String = String()
    var _type: String = String()
    var _accelerationData: AccelerationDataProto2? = nil
    var _gyroData: GyroDataProto2? = nil
    var _imageData: ImageProto? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _timestamp = source._timestamp
      _session = source._session
      _type = source._type
      _accelerationData = source._accelerationData
      _gyroData = source._gyroData
      _imageData = source._imageData
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularDoubleField(value: &_storage._timestamp)
        case 2: try decoder.decodeSingularStringField(value: &_storage._session)
        case 3: try decoder.decodeSingularStringField(value: &_storage._type)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._accelerationData)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._gyroData)
        case 6: try decoder.decodeSingularMessageField(value: &_storage._imageData)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._timestamp != 0 {
        try visitor.visitSingularDoubleField(value: _storage._timestamp, fieldNumber: 1)
      }
      if !_storage._session.isEmpty {
        try visitor.visitSingularStringField(value: _storage._session, fieldNumber: 2)
      }
      if !_storage._type.isEmpty {
        try visitor.visitSingularStringField(value: _storage._type, fieldNumber: 3)
      }
      if let v = _storage._accelerationData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._gyroData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if let v = _storage._imageData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SensorUpdate, rhs: SensorUpdate) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._timestamp != rhs_storage._timestamp {return false}
        if _storage._session != rhs_storage._session {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._accelerationData != rhs_storage._accelerationData {return false}
        if _storage._gyroData != rhs_storage._gyroData {return false}
        if _storage._imageData != rhs_storage._imageData {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
