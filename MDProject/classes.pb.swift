// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: classes.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct ProfileProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var serverAddress: String = String()

  var serverPort: UInt32 = 0

  var sessionName: String = String()

  var sensor: [SensorProto] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SensorProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var name: String = String()

  var status: Bool = false

  var parameter: [SensorParameterProto] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SensorParameterProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var key: String {
    get {return _storage._key}
    set {_uniqueStorage()._key = newValue}
  }

  var value: SensorParameterValueProto {
    get {return _storage._value ?? SensorParameterValueProto()}
    set {_uniqueStorage()._value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  var hasValue: Bool {return _storage._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  mutating func clearValue() {_uniqueStorage()._value = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct SensorParameterValueProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var doubleValue: Double = 0

  var strValue: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct AccelerationDataProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var x: Double = 0

  var y: Double = 0

  var z: Double = 0

  var timestamp: Double = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct GyroDataProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var x: Double = 0

  var y: Double = 0

  var z: Double = 0

  var timestamp: Double = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct DataProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var accelerationData: [AccelerationDataProto] = []

  var gyroData: [GyroDataProto] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct GyroDataProto2 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var x: Double = 0

  var y: Double = 0

  var z: Double = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct AccelerationDataProto2 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var x: Double = 0

  var y: Double = 0

  var z: Double = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct ImageProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var base64: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct ImageProto2 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var jpegImage: Data {
    get {return _storage._jpegImage}
    set {_uniqueStorage()._jpegImage = newValue}
  }

  var trackingState: String {
    get {return _storage._trackingState}
    set {_uniqueStorage()._trackingState = newValue}
  }

  var arKitPoses: ArKit6dPosesDataProto {
    get {return _storage._arKitPoses ?? ArKit6dPosesDataProto()}
    set {_uniqueStorage()._arKitPoses = newValue}
  }
  /// Returns true if `arKitPoses` has been explicitly set.
  var hasArKitPoses: Bool {return _storage._arKitPoses != nil}
  /// Clears the value of `arKitPoses`. Subsequent reads from it will return its default value.
  mutating func clearArKitPoses() {_uniqueStorage()._arKitPoses = nil}

  var pointsCloud: [PointCloudDataProto] {
    get {return _storage._pointsCloud}
    set {_uniqueStorage()._pointsCloud = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct PointCloudDataProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var x: Float = 0

  var y: Float = 0

  var z: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct MagnetometerDataProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var x: Double = 0

  var y: Double = 0

  var z: Double = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CompassDataProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var x: Double = 0

  var y: Double = 0

  var z: Double = 0

  var trueHeading: Double = 0

  var magneticHeading: Double = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct ArKit6dPosesDataProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var transformPoses: TransformationMatrixDataProto {
    get {return _storage._transformPoses ?? TransformationMatrixDataProto()}
    set {_uniqueStorage()._transformPoses = newValue}
  }
  /// Returns true if `transformPoses` has been explicitly set.
  var hasTransformPoses: Bool {return _storage._transformPoses != nil}
  /// Clears the value of `transformPoses`. Subsequent reads from it will return its default value.
  mutating func clearTransformPoses() {_uniqueStorage()._transformPoses = nil}

  var eulerAngles: EulerAnglesDataProto {
    get {return _storage._eulerAngles ?? EulerAnglesDataProto()}
    set {_uniqueStorage()._eulerAngles = newValue}
  }
  /// Returns true if `eulerAngles` has been explicitly set.
  var hasEulerAngles: Bool {return _storage._eulerAngles != nil}
  /// Clears the value of `eulerAngles`. Subsequent reads from it will return its default value.
  mutating func clearEulerAngles() {_uniqueStorage()._eulerAngles = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TransformationMatrixDataProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var firstColumn: TransformationVectorDataProto {
    get {return _storage._firstColumn ?? TransformationVectorDataProto()}
    set {_uniqueStorage()._firstColumn = newValue}
  }
  /// Returns true if `firstColumn` has been explicitly set.
  var hasFirstColumn: Bool {return _storage._firstColumn != nil}
  /// Clears the value of `firstColumn`. Subsequent reads from it will return its default value.
  mutating func clearFirstColumn() {_uniqueStorage()._firstColumn = nil}

  var secondColumn: TransformationVectorDataProto {
    get {return _storage._secondColumn ?? TransformationVectorDataProto()}
    set {_uniqueStorage()._secondColumn = newValue}
  }
  /// Returns true if `secondColumn` has been explicitly set.
  var hasSecondColumn: Bool {return _storage._secondColumn != nil}
  /// Clears the value of `secondColumn`. Subsequent reads from it will return its default value.
  mutating func clearSecondColumn() {_uniqueStorage()._secondColumn = nil}

  var thirdColumn: TransformationVectorDataProto {
    get {return _storage._thirdColumn ?? TransformationVectorDataProto()}
    set {_uniqueStorage()._thirdColumn = newValue}
  }
  /// Returns true if `thirdColumn` has been explicitly set.
  var hasThirdColumn: Bool {return _storage._thirdColumn != nil}
  /// Clears the value of `thirdColumn`. Subsequent reads from it will return its default value.
  mutating func clearThirdColumn() {_uniqueStorage()._thirdColumn = nil}

  var fourthColumn: TransformationVectorDataProto {
    get {return _storage._fourthColumn ?? TransformationVectorDataProto()}
    set {_uniqueStorage()._fourthColumn = newValue}
  }
  /// Returns true if `fourthColumn` has been explicitly set.
  var hasFourthColumn: Bool {return _storage._fourthColumn != nil}
  /// Clears the value of `fourthColumn`. Subsequent reads from it will return its default value.
  mutating func clearFourthColumn() {_uniqueStorage()._fourthColumn = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TransformationVectorDataProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var x: Float = 0

  var y: Float = 0

  var z: Float = 0

  var w: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct EulerAnglesDataProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var yaw: Float = 0

  var pitch: Float = 0

  var roll: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PlaneDataProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var width: Float = 0

  var height: Float = 0

  var x: Float = 0

  var y: Float = 0

  var z: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SensorUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var timestamp: Double {
    get {return _storage._timestamp}
    set {_uniqueStorage()._timestamp = newValue}
  }

  var session: String {
    get {return _storage._session}
    set {_uniqueStorage()._session = newValue}
  }

  var type: String {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  var accelerationData: AccelerationDataProto2 {
    get {return _storage._accelerationData ?? AccelerationDataProto2()}
    set {_uniqueStorage()._accelerationData = newValue}
  }
  /// Returns true if `accelerationData` has been explicitly set.
  var hasAccelerationData: Bool {return _storage._accelerationData != nil}
  /// Clears the value of `accelerationData`. Subsequent reads from it will return its default value.
  mutating func clearAccelerationData() {_uniqueStorage()._accelerationData = nil}

  var gyroData: GyroDataProto2 {
    get {return _storage._gyroData ?? GyroDataProto2()}
    set {_uniqueStorage()._gyroData = newValue}
  }
  /// Returns true if `gyroData` has been explicitly set.
  var hasGyroData: Bool {return _storage._gyroData != nil}
  /// Clears the value of `gyroData`. Subsequent reads from it will return its default value.
  mutating func clearGyroData() {_uniqueStorage()._gyroData = nil}

  var imageData: ImageProto {
    get {return _storage._imageData ?? ImageProto()}
    set {_uniqueStorage()._imageData = newValue}
  }
  /// Returns true if `imageData` has been explicitly set.
  var hasImageData: Bool {return _storage._imageData != nil}
  /// Clears the value of `imageData`. Subsequent reads from it will return its default value.
  mutating func clearImageData() {_uniqueStorage()._imageData = nil}

  var jpegImage: ImageProto2 {
    get {return _storage._jpegImage ?? ImageProto2()}
    set {_uniqueStorage()._jpegImage = newValue}
  }
  /// Returns true if `jpegImage` has been explicitly set.
  var hasJpegImage: Bool {return _storage._jpegImage != nil}
  /// Clears the value of `jpegImage`. Subsequent reads from it will return its default value.
  mutating func clearJpegImage() {_uniqueStorage()._jpegImage = nil}

  var planeData: PlaneDataProto {
    get {return _storage._planeData ?? PlaneDataProto()}
    set {_uniqueStorage()._planeData = newValue}
  }
  /// Returns true if `planeData` has been explicitly set.
  var hasPlaneData: Bool {return _storage._planeData != nil}
  /// Clears the value of `planeData`. Subsequent reads from it will return its default value.
  mutating func clearPlaneData() {_uniqueStorage()._planeData = nil}

  var magnetometerData: MagnetometerDataProto {
    get {return _storage._magnetometerData ?? MagnetometerDataProto()}
    set {_uniqueStorage()._magnetometerData = newValue}
  }
  /// Returns true if `magnetometerData` has been explicitly set.
  var hasMagnetometerData: Bool {return _storage._magnetometerData != nil}
  /// Clears the value of `magnetometerData`. Subsequent reads from it will return its default value.
  mutating func clearMagnetometerData() {_uniqueStorage()._magnetometerData = nil}

  var compassData: CompassDataProto {
    get {return _storage._compassData ?? CompassDataProto()}
    set {_uniqueStorage()._compassData = newValue}
  }
  /// Returns true if `compassData` has been explicitly set.
  var hasCompassData: Bool {return _storage._compassData != nil}
  /// Clears the value of `compassData`. Subsequent reads from it will return its default value.
  mutating func clearCompassData() {_uniqueStorage()._compassData = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension ProfileProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ProfileProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "serverAddress"),
    2: .same(proto: "serverPort"),
    3: .same(proto: "sessionName"),
    4: .same(proto: "sensor"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.serverAddress)
      case 2: try decoder.decodeSingularUInt32Field(value: &self.serverPort)
      case 3: try decoder.decodeSingularStringField(value: &self.sessionName)
      case 4: try decoder.decodeRepeatedMessageField(value: &self.sensor)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.serverAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.serverAddress, fieldNumber: 1)
    }
    if self.serverPort != 0 {
      try visitor.visitSingularUInt32Field(value: self.serverPort, fieldNumber: 2)
    }
    if !self.sessionName.isEmpty {
      try visitor.visitSingularStringField(value: self.sessionName, fieldNumber: 3)
    }
    if !self.sensor.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sensor, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ProfileProto, rhs: ProfileProto) -> Bool {
    if lhs.serverAddress != rhs.serverAddress {return false}
    if lhs.serverPort != rhs.serverPort {return false}
    if lhs.sessionName != rhs.sessionName {return false}
    if lhs.sensor != rhs.sensor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SensorProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "SensorProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "status"),
    3: .same(proto: "parameter"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.name)
      case 2: try decoder.decodeSingularBoolField(value: &self.status)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.parameter)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.status != false {
      try visitor.visitSingularBoolField(value: self.status, fieldNumber: 2)
    }
    if !self.parameter.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.parameter, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SensorProto, rhs: SensorProto) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.status != rhs.status {return false}
    if lhs.parameter != rhs.parameter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SensorParameterProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "SensorParameterProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "value"),
  ]

  fileprivate class _StorageClass {
    var _key: String = String()
    var _value: SensorParameterValueProto? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _key = source._key
      _value = source._value
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._key)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._value)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._key.isEmpty {
        try visitor.visitSingularStringField(value: _storage._key, fieldNumber: 1)
      }
      if let v = _storage._value {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SensorParameterProto, rhs: SensorParameterProto) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._key != rhs_storage._key {return false}
        if _storage._value != rhs_storage._value {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SensorParameterValueProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "SensorParameterValueProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "doubleValue"),
    2: .same(proto: "strValue"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularDoubleField(value: &self.doubleValue)
      case 2: try decoder.decodeSingularStringField(value: &self.strValue)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.doubleValue != 0 {
      try visitor.visitSingularDoubleField(value: self.doubleValue, fieldNumber: 1)
    }
    if !self.strValue.isEmpty {
      try visitor.visitSingularStringField(value: self.strValue, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SensorParameterValueProto, rhs: SensorParameterValueProto) -> Bool {
    if lhs.doubleValue != rhs.doubleValue {return false}
    if lhs.strValue != rhs.strValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AccelerationDataProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "AccelerationDataProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "x"),
    2: .same(proto: "y"),
    3: .same(proto: "z"),
    4: .same(proto: "timestamp"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularDoubleField(value: &self.x)
      case 2: try decoder.decodeSingularDoubleField(value: &self.y)
      case 3: try decoder.decodeSingularDoubleField(value: &self.z)
      case 4: try decoder.decodeSingularDoubleField(value: &self.timestamp)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.x != 0 {
      try visitor.visitSingularDoubleField(value: self.x, fieldNumber: 1)
    }
    if self.y != 0 {
      try visitor.visitSingularDoubleField(value: self.y, fieldNumber: 2)
    }
    if self.z != 0 {
      try visitor.visitSingularDoubleField(value: self.z, fieldNumber: 3)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularDoubleField(value: self.timestamp, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AccelerationDataProto, rhs: AccelerationDataProto) -> Bool {
    if lhs.x != rhs.x {return false}
    if lhs.y != rhs.y {return false}
    if lhs.z != rhs.z {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GyroDataProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "GyroDataProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "x"),
    2: .same(proto: "y"),
    3: .same(proto: "z"),
    4: .same(proto: "timestamp"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularDoubleField(value: &self.x)
      case 2: try decoder.decodeSingularDoubleField(value: &self.y)
      case 3: try decoder.decodeSingularDoubleField(value: &self.z)
      case 4: try decoder.decodeSingularDoubleField(value: &self.timestamp)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.x != 0 {
      try visitor.visitSingularDoubleField(value: self.x, fieldNumber: 1)
    }
    if self.y != 0 {
      try visitor.visitSingularDoubleField(value: self.y, fieldNumber: 2)
    }
    if self.z != 0 {
      try visitor.visitSingularDoubleField(value: self.z, fieldNumber: 3)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularDoubleField(value: self.timestamp, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GyroDataProto, rhs: GyroDataProto) -> Bool {
    if lhs.x != rhs.x {return false}
    if lhs.y != rhs.y {return false}
    if lhs.z != rhs.z {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DataProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "DataProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "accelerationData"),
    2: .same(proto: "gyroData"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.accelerationData)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.gyroData)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.accelerationData.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.accelerationData, fieldNumber: 1)
    }
    if !self.gyroData.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.gyroData, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DataProto, rhs: DataProto) -> Bool {
    if lhs.accelerationData != rhs.accelerationData {return false}
    if lhs.gyroData != rhs.gyroData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GyroDataProto2: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "GyroDataProto2"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "x"),
    2: .same(proto: "y"),
    3: .same(proto: "z"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularDoubleField(value: &self.x)
      case 2: try decoder.decodeSingularDoubleField(value: &self.y)
      case 3: try decoder.decodeSingularDoubleField(value: &self.z)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.x != 0 {
      try visitor.visitSingularDoubleField(value: self.x, fieldNumber: 1)
    }
    if self.y != 0 {
      try visitor.visitSingularDoubleField(value: self.y, fieldNumber: 2)
    }
    if self.z != 0 {
      try visitor.visitSingularDoubleField(value: self.z, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GyroDataProto2, rhs: GyroDataProto2) -> Bool {
    if lhs.x != rhs.x {return false}
    if lhs.y != rhs.y {return false}
    if lhs.z != rhs.z {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AccelerationDataProto2: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "AccelerationDataProto2"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "x"),
    2: .same(proto: "y"),
    3: .same(proto: "z"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularDoubleField(value: &self.x)
      case 2: try decoder.decodeSingularDoubleField(value: &self.y)
      case 3: try decoder.decodeSingularDoubleField(value: &self.z)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.x != 0 {
      try visitor.visitSingularDoubleField(value: self.x, fieldNumber: 1)
    }
    if self.y != 0 {
      try visitor.visitSingularDoubleField(value: self.y, fieldNumber: 2)
    }
    if self.z != 0 {
      try visitor.visitSingularDoubleField(value: self.z, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AccelerationDataProto2, rhs: AccelerationDataProto2) -> Bool {
    if lhs.x != rhs.x {return false}
    if lhs.y != rhs.y {return false}
    if lhs.z != rhs.z {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ImageProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ImageProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "base64"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.base64)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.base64.isEmpty {
      try visitor.visitSingularStringField(value: self.base64, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ImageProto, rhs: ImageProto) -> Bool {
    if lhs.base64 != rhs.base64 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ImageProto2: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ImageProto2"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "JpegImage"),
    2: .same(proto: "TrackingState"),
    3: .same(proto: "arKitPoses"),
    4: .same(proto: "PointsCloud"),
  ]

  fileprivate class _StorageClass {
    var _jpegImage: Data = SwiftProtobuf.Internal.emptyData
    var _trackingState: String = String()
    var _arKitPoses: ArKit6dPosesDataProto? = nil
    var _pointsCloud: [PointCloudDataProto] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _jpegImage = source._jpegImage
      _trackingState = source._trackingState
      _arKitPoses = source._arKitPoses
      _pointsCloud = source._pointsCloud
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularBytesField(value: &_storage._jpegImage)
        case 2: try decoder.decodeSingularStringField(value: &_storage._trackingState)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._arKitPoses)
        case 4: try decoder.decodeRepeatedMessageField(value: &_storage._pointsCloud)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._jpegImage.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._jpegImage, fieldNumber: 1)
      }
      if !_storage._trackingState.isEmpty {
        try visitor.visitSingularStringField(value: _storage._trackingState, fieldNumber: 2)
      }
      if let v = _storage._arKitPoses {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if !_storage._pointsCloud.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._pointsCloud, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ImageProto2, rhs: ImageProto2) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._jpegImage != rhs_storage._jpegImage {return false}
        if _storage._trackingState != rhs_storage._trackingState {return false}
        if _storage._arKitPoses != rhs_storage._arKitPoses {return false}
        if _storage._pointsCloud != rhs_storage._pointsCloud {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PointCloudDataProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PointCloudDataProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "x"),
    2: .same(proto: "y"),
    3: .same(proto: "z"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularFloatField(value: &self.x)
      case 2: try decoder.decodeSingularFloatField(value: &self.y)
      case 3: try decoder.decodeSingularFloatField(value: &self.z)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.x != 0 {
      try visitor.visitSingularFloatField(value: self.x, fieldNumber: 1)
    }
    if self.y != 0 {
      try visitor.visitSingularFloatField(value: self.y, fieldNumber: 2)
    }
    if self.z != 0 {
      try visitor.visitSingularFloatField(value: self.z, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PointCloudDataProto, rhs: PointCloudDataProto) -> Bool {
    if lhs.x != rhs.x {return false}
    if lhs.y != rhs.y {return false}
    if lhs.z != rhs.z {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MagnetometerDataProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "MagnetometerDataProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "x"),
    2: .same(proto: "y"),
    3: .same(proto: "z"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularDoubleField(value: &self.x)
      case 2: try decoder.decodeSingularDoubleField(value: &self.y)
      case 3: try decoder.decodeSingularDoubleField(value: &self.z)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.x != 0 {
      try visitor.visitSingularDoubleField(value: self.x, fieldNumber: 1)
    }
    if self.y != 0 {
      try visitor.visitSingularDoubleField(value: self.y, fieldNumber: 2)
    }
    if self.z != 0 {
      try visitor.visitSingularDoubleField(value: self.z, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: MagnetometerDataProto, rhs: MagnetometerDataProto) -> Bool {
    if lhs.x != rhs.x {return false}
    if lhs.y != rhs.y {return false}
    if lhs.z != rhs.z {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CompassDataProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CompassDataProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "x"),
    2: .same(proto: "y"),
    3: .same(proto: "z"),
    4: .same(proto: "trueHeading"),
    5: .same(proto: "magneticHeading"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularDoubleField(value: &self.x)
      case 2: try decoder.decodeSingularDoubleField(value: &self.y)
      case 3: try decoder.decodeSingularDoubleField(value: &self.z)
      case 4: try decoder.decodeSingularDoubleField(value: &self.trueHeading)
      case 5: try decoder.decodeSingularDoubleField(value: &self.magneticHeading)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.x != 0 {
      try visitor.visitSingularDoubleField(value: self.x, fieldNumber: 1)
    }
    if self.y != 0 {
      try visitor.visitSingularDoubleField(value: self.y, fieldNumber: 2)
    }
    if self.z != 0 {
      try visitor.visitSingularDoubleField(value: self.z, fieldNumber: 3)
    }
    if self.trueHeading != 0 {
      try visitor.visitSingularDoubleField(value: self.trueHeading, fieldNumber: 4)
    }
    if self.magneticHeading != 0 {
      try visitor.visitSingularDoubleField(value: self.magneticHeading, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CompassDataProto, rhs: CompassDataProto) -> Bool {
    if lhs.x != rhs.x {return false}
    if lhs.y != rhs.y {return false}
    if lhs.z != rhs.z {return false}
    if lhs.trueHeading != rhs.trueHeading {return false}
    if lhs.magneticHeading != rhs.magneticHeading {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ArKit6dPosesDataProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ArKit6dPosesDataProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "transformPoses"),
    2: .same(proto: "eulerAngles"),
  ]

  fileprivate class _StorageClass {
    var _transformPoses: TransformationMatrixDataProto? = nil
    var _eulerAngles: EulerAnglesDataProto? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _transformPoses = source._transformPoses
      _eulerAngles = source._eulerAngles
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._transformPoses)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._eulerAngles)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._transformPoses {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._eulerAngles {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ArKit6dPosesDataProto, rhs: ArKit6dPosesDataProto) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._transformPoses != rhs_storage._transformPoses {return false}
        if _storage._eulerAngles != rhs_storage._eulerAngles {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TransformationMatrixDataProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "TransformationMatrixDataProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "firstColumn"),
    2: .same(proto: "secondColumn"),
    3: .same(proto: "thirdColumn"),
    4: .same(proto: "fourthColumn"),
  ]

  fileprivate class _StorageClass {
    var _firstColumn: TransformationVectorDataProto? = nil
    var _secondColumn: TransformationVectorDataProto? = nil
    var _thirdColumn: TransformationVectorDataProto? = nil
    var _fourthColumn: TransformationVectorDataProto? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _firstColumn = source._firstColumn
      _secondColumn = source._secondColumn
      _thirdColumn = source._thirdColumn
      _fourthColumn = source._fourthColumn
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._firstColumn)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._secondColumn)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._thirdColumn)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._fourthColumn)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._firstColumn {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._secondColumn {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._thirdColumn {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._fourthColumn {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TransformationMatrixDataProto, rhs: TransformationMatrixDataProto) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._firstColumn != rhs_storage._firstColumn {return false}
        if _storage._secondColumn != rhs_storage._secondColumn {return false}
        if _storage._thirdColumn != rhs_storage._thirdColumn {return false}
        if _storage._fourthColumn != rhs_storage._fourthColumn {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TransformationVectorDataProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "TransformationVectorDataProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "x"),
    2: .same(proto: "y"),
    3: .same(proto: "z"),
    4: .same(proto: "w"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularFloatField(value: &self.x)
      case 2: try decoder.decodeSingularFloatField(value: &self.y)
      case 3: try decoder.decodeSingularFloatField(value: &self.z)
      case 4: try decoder.decodeSingularFloatField(value: &self.w)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.x != 0 {
      try visitor.visitSingularFloatField(value: self.x, fieldNumber: 1)
    }
    if self.y != 0 {
      try visitor.visitSingularFloatField(value: self.y, fieldNumber: 2)
    }
    if self.z != 0 {
      try visitor.visitSingularFloatField(value: self.z, fieldNumber: 3)
    }
    if self.w != 0 {
      try visitor.visitSingularFloatField(value: self.w, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TransformationVectorDataProto, rhs: TransformationVectorDataProto) -> Bool {
    if lhs.x != rhs.x {return false}
    if lhs.y != rhs.y {return false}
    if lhs.z != rhs.z {return false}
    if lhs.w != rhs.w {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EulerAnglesDataProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "EulerAnglesDataProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "yaw"),
    2: .same(proto: "pitch"),
    3: .same(proto: "roll"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularFloatField(value: &self.yaw)
      case 2: try decoder.decodeSingularFloatField(value: &self.pitch)
      case 3: try decoder.decodeSingularFloatField(value: &self.roll)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.yaw != 0 {
      try visitor.visitSingularFloatField(value: self.yaw, fieldNumber: 1)
    }
    if self.pitch != 0 {
      try visitor.visitSingularFloatField(value: self.pitch, fieldNumber: 2)
    }
    if self.roll != 0 {
      try visitor.visitSingularFloatField(value: self.roll, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: EulerAnglesDataProto, rhs: EulerAnglesDataProto) -> Bool {
    if lhs.yaw != rhs.yaw {return false}
    if lhs.pitch != rhs.pitch {return false}
    if lhs.roll != rhs.roll {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PlaneDataProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PlaneDataProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "width"),
    2: .same(proto: "height"),
    3: .same(proto: "x"),
    4: .same(proto: "y"),
    5: .same(proto: "z"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularFloatField(value: &self.width)
      case 2: try decoder.decodeSingularFloatField(value: &self.height)
      case 3: try decoder.decodeSingularFloatField(value: &self.x)
      case 4: try decoder.decodeSingularFloatField(value: &self.y)
      case 5: try decoder.decodeSingularFloatField(value: &self.z)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.width != 0 {
      try visitor.visitSingularFloatField(value: self.width, fieldNumber: 1)
    }
    if self.height != 0 {
      try visitor.visitSingularFloatField(value: self.height, fieldNumber: 2)
    }
    if self.x != 0 {
      try visitor.visitSingularFloatField(value: self.x, fieldNumber: 3)
    }
    if self.y != 0 {
      try visitor.visitSingularFloatField(value: self.y, fieldNumber: 4)
    }
    if self.z != 0 {
      try visitor.visitSingularFloatField(value: self.z, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PlaneDataProto, rhs: PlaneDataProto) -> Bool {
    if lhs.width != rhs.width {return false}
    if lhs.height != rhs.height {return false}
    if lhs.x != rhs.x {return false}
    if lhs.y != rhs.y {return false}
    if lhs.z != rhs.z {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SensorUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "SensorUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "timestamp"),
    2: .same(proto: "session"),
    3: .same(proto: "type"),
    4: .same(proto: "accelerationData"),
    5: .same(proto: "gyroData"),
    6: .same(proto: "ImageData"),
    7: .same(proto: "JpegImage"),
    8: .same(proto: "planeData"),
    9: .same(proto: "magnetometerData"),
    10: .same(proto: "compassData"),
  ]

  fileprivate class _StorageClass {
    var _timestamp: Double = 0
    var _session: String = String()
    var _type: String = String()
    var _accelerationData: AccelerationDataProto2? = nil
    var _gyroData: GyroDataProto2? = nil
    var _imageData: ImageProto? = nil
    var _jpegImage: ImageProto2? = nil
    var _planeData: PlaneDataProto? = nil
    var _magnetometerData: MagnetometerDataProto? = nil
    var _compassData: CompassDataProto? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _timestamp = source._timestamp
      _session = source._session
      _type = source._type
      _accelerationData = source._accelerationData
      _gyroData = source._gyroData
      _imageData = source._imageData
      _jpegImage = source._jpegImage
      _planeData = source._planeData
      _magnetometerData = source._magnetometerData
      _compassData = source._compassData
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularDoubleField(value: &_storage._timestamp)
        case 2: try decoder.decodeSingularStringField(value: &_storage._session)
        case 3: try decoder.decodeSingularStringField(value: &_storage._type)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._accelerationData)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._gyroData)
        case 6: try decoder.decodeSingularMessageField(value: &_storage._imageData)
        case 7: try decoder.decodeSingularMessageField(value: &_storage._jpegImage)
        case 8: try decoder.decodeSingularMessageField(value: &_storage._planeData)
        case 9: try decoder.decodeSingularMessageField(value: &_storage._magnetometerData)
        case 10: try decoder.decodeSingularMessageField(value: &_storage._compassData)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._timestamp != 0 {
        try visitor.visitSingularDoubleField(value: _storage._timestamp, fieldNumber: 1)
      }
      if !_storage._session.isEmpty {
        try visitor.visitSingularStringField(value: _storage._session, fieldNumber: 2)
      }
      if !_storage._type.isEmpty {
        try visitor.visitSingularStringField(value: _storage._type, fieldNumber: 3)
      }
      if let v = _storage._accelerationData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._gyroData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if let v = _storage._imageData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if let v = _storage._jpegImage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if let v = _storage._planeData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
      if let v = _storage._magnetometerData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }
      if let v = _storage._compassData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SensorUpdate, rhs: SensorUpdate) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._timestamp != rhs_storage._timestamp {return false}
        if _storage._session != rhs_storage._session {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._accelerationData != rhs_storage._accelerationData {return false}
        if _storage._gyroData != rhs_storage._gyroData {return false}
        if _storage._imageData != rhs_storage._imageData {return false}
        if _storage._jpegImage != rhs_storage._jpegImage {return false}
        if _storage._planeData != rhs_storage._planeData {return false}
        if _storage._magnetometerData != rhs_storage._magnetometerData {return false}
        if _storage._compassData != rhs_storage._compassData {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
